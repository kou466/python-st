# 2025-02-28

## Chap03 조건문

- Boolean
    - True / False

    - 비교 연산자
        - ==
        - !=
        - >
        - <
        - >=
        - <=

        - 문자열에도 비교 연산자 사용 가능
            - 사전순으로 비교

- 논리 연산자
    - and
        - 조건 중 하나라도 False이면 False
    - or
        - 조건 중 하나라도 True이면 True
    - not
        - True -> False
        - False -> True

- 조건문
    - if
    - elif
    - else

    - if 조건문의 매개변수에 Boolean 타입이 아닌 값을 넣으면 자동으로 Boolean 타입으로 변환
    - False로 변환되는 값은 0, 0.0, None, 빈 컨테이너(빈 문자열, 빈 리스트, 빈 딕셔너리, 빈 튜플, 빈 세트 등)

- pass 키워드
    - 아무것도 하지 않음
    - 조건문의 매개변수에 들어가는 코드 블록을 작성할 때 사용
    - 예시

```python
if 조건문:
    pass
elif 조건문:
    pass
else:
    pass
```

> ### raise NotImplementedError
> - 아직 구현되지 않은 기능을 작성할 때 사용  
> - 조건문의 코드블록 내부에 사용 가능

--- 

## Chap04 반복문

- 리스트
    - `array = [1, 2, 3, 4, 5]`
    - 배열의 각 요소에 접근하려면 인덱스를 사용
    1. 요소 접근
        - `array[0]` = 1 (첫 번째 요소)
        - `array[1]` = 2 (두 번째 요소)
        - `array[-1]` = 5 (마지막 요소)
        - `array[-2]` = 4 (뒤에서 두 번째 요소)
    2. 리스트 접근 연산자 이중 사용
        - `list_a = [1,2,3,"문자열", True, False]`
        - `list_a[3] = "문자열"`
        - `list_a[3][0] = "문"`
    3. 리스트 안에 리스트 사용
        - `list_a = [1,2,3,[4,5,6]]`
        - `list_a[3] = [4,5,6]`
        - `list_a[3][0] = 4`

    - 리스트 연산
        - + : 리스트 합치기
        - * : 리스트 반복
        - len() : 리스트 길이

    - 리스트 함수
        - append() : 리스트 마지막에 요소 추가
            - `list_a.append(요소)`
        - insert() : 리스트 특정 위치에 요소 추가
            - `list_a.insert(위치, 요소)`
            - 예시
                 ```python
                 >>> list_a = [1,2,3,4,5]
                 >>> list_a.insert(2, 99)
                 >>> list_a
                 [1,2,99,3,4,5]
                 ```
        - extend() : 리스트에 다른 리스트를 추가하여 확장
            - `list_a.extend(리스트)`
            - 예시
                 ```python
                 >>> list_a = [1,2,3]
                 >>> list_b = [4,5,6]
                 >>> list_a.extend(list_b)
                 >>> list_a
                 [1,2,3,4,5,6]
                 ```
        > - `+` 연산자와 `extend()` 함수의 차이
        >     - 비파괴적, 파괴적
        >         - 비파괴적: 원본 데이터를 변경하지 않고 새로운 객체를 생성하는 방식 (예: `+` 연산자)
        >         - 파괴적: 원본 데이터를 직접 수정하는 방식 (예: `extend()` 함수)
        >         - 원래 자료는 비파괴적으로 사용하는 것이 편리함. 원본도 활용할 수 있기 때문.
        >         - 기본 자료형(숫자, 문자열, 불리언)은 비파괴적으로 작동함
        >     - 예시
        >         ```python
        >         >>> list_a = [1,2,3]
        >         >>> list_b = [4,5,6]
        >         >>> list_a + list_b
        >         [1,2,3,4,5,6]
        >         >>> list_a
        >         [1,2,3]
        >         >>> list_b
        >         [4,5,6]
        >         ```
        >         ```python
        >         >>> list_a = [1,2,3]
        >         >>> list_b = [4,5,6]
        >         >>> list_a.extend(list_b)
        >         >>> list_a
        >         [1,2,3,4,5,6]
        >         ```

    - 리스트 요소 제거
        - 인덱스로 제거
            - `del 리스트명[인덱스]`
                - 범위를 지정하여 리스트의 요소를 한꺼번에 제거할 수 있음
            - `리스트명.pop(인덱스)`
                - 매개변수 없으면(-1로 취급) 마지막 요소 제거 
        - 값으로 제거
            - `리스트명.remove(값)`
                - 값이 여러 개일 경우 첫 번째 값만 제거
            - `리스트명.clear()`
                - 리스트의 모든 요소 제거

> 리스트 슬라이싱
> - 리스트의 일부를 추출하는 방법
> - 범위를 지정하여 리스트의 요소를 한꺼번에 추출할 수 있음
> - `리스트[시작_인덱스:끝_인덱스:단계]`
> - 예시
>     ```python
>     >>> list_a = [1,2,3,4,5,6,7,8]
>     >>> list_a[0:5:2]
>     [1,3,5]
>     >>> list_a[::-1]
>     [8,7,6,5,4,3,2,1]
>     >>> list_a[::2]
>     [1,3,5,7]
>     >>> list_a[::-2]
>     [8,6,4,2]
>     >>> list_a[3:6]
>     [4,5,6]
>     ```

- 